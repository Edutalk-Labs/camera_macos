// Copyright 2013 The Flutter Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Autogenerated from Pigeon (v9.2.5), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
#if os(iOS)
import Flutter
#elseif os(macOS)
import FlutterMacOS
#else
#error("Unsupported platform.")
#endif

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)"
  ]
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return (value as Any) as! T?
}

enum PlatformCameraLensDirection: Int {
  /// Front facing camera (a user looking at the screen is seen by the camera).
  case front = 0
  /// Back facing camera (a user looking at the screen is not seen by the camera).
  case back = 1
  /// External camera which may not be mounted to the device.
  case external = 2
}

enum PlatformDeviceOrientation: Int {
  case portraitUp = 0
  case landscapeLeft = 1
  case portraitDown = 2
  case landscapeRight = 3
}

enum PlatformExposureMode: Int {
  case auto = 0
  case locked = 1
}

enum PlatformFlashMode: Int {
  case off = 0
  case auto = 1
  case always = 2
  case torch = 3
}

enum PlatformFocusMode: Int {
  case auto = 0
  case locked = 1
}

/// Pigeon version of ImageFileFormat.
enum PlatformImageFileFormat: Int {
  case jpeg = 0
  case heif = 1
}

enum PlatformImageFormatGroup: Int {
  case bgra8888 = 0
  case yuv420 = 1
}

enum PlatformResolutionPreset: Int {
  case low = 0
  case medium = 1
  case high = 2
  case veryHigh = 3
  case ultraHigh = 4
  case max = 5
}

/// Generated class from Pigeon that represents data sent in messages.
struct PlatformCameraDescription {
  /// The name of the camera device.
  var name: String
  /// The direction the camera is facing.
  var lensDirection: PlatformCameraLensDirection

  static func fromList(_ list: [Any]) -> PlatformCameraDescription? {
    let name = list[0] as! String
    let lensDirection = PlatformCameraLensDirection(rawValue: list[1] as! Int)!

    return PlatformCameraDescription(
      name: name,
      lensDirection: lensDirection
    )
  }
  func toList() -> [Any?] {
    return [
      name,
      lensDirection.rawValue,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PlatformCameraState {
  /// The size of the preview, in pixels.
  var previewSize: PlatformSize
  /// The default exposure mode
  var exposureMode: PlatformExposureMode
  /// The default focus mode
  var focusMode: PlatformFocusMode
  /// Whether setting exposure points is supported.
  var exposurePointSupported: Bool
  /// Whether setting focus points is supported.
  var focusPointSupported: Bool

  static func fromList(_ list: [Any]) -> PlatformCameraState? {
    let previewSize = PlatformSize.fromList(list[0] as! [Any])!
    let exposureMode = PlatformExposureMode(rawValue: list[1] as! Int)!
    let focusMode = PlatformFocusMode(rawValue: list[2] as! Int)!
    let exposurePointSupported = list[3] as! Bool
    let focusPointSupported = list[4] as! Bool

    return PlatformCameraState(
      previewSize: previewSize,
      exposureMode: exposureMode,
      focusMode: focusMode,
      exposurePointSupported: exposurePointSupported,
      focusPointSupported: focusPointSupported
    )
  }
  func toList() -> [Any?] {
    return [
      previewSize.toList(),
      exposureMode.rawValue,
      focusMode.rawValue,
      exposurePointSupported,
      focusPointSupported,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PlatformMediaSettings {
  var resolutionPreset: PlatformResolutionPreset
  var framesPerSecond: Int64? = nil
  var videoBitrate: Int64? = nil
  var audioBitrate: Int64? = nil
  var enableAudio: Bool

  static func fromList(_ list: [Any]) -> PlatformMediaSettings? {
    let resolutionPreset = PlatformResolutionPreset(rawValue: list[0] as! Int)!
    let framesPerSecond: Int64? = list[1] is NSNull ? nil : (list[1] is Int64? ? list[1] as! Int64? : Int64(list[1] as! Int32))
    let videoBitrate: Int64? = list[2] is NSNull ? nil : (list[2] is Int64? ? list[2] as! Int64? : Int64(list[2] as! Int32))
    let audioBitrate: Int64? = list[3] is NSNull ? nil : (list[3] is Int64? ? list[3] as! Int64? : Int64(list[3] as! Int32))
    let enableAudio = list[4] as! Bool

    return PlatformMediaSettings(
      resolutionPreset: resolutionPreset,
      framesPerSecond: framesPerSecond,
      videoBitrate: videoBitrate,
      audioBitrate: audioBitrate,
      enableAudio: enableAudio
    )
  }
  func toList() -> [Any?] {
    return [
      resolutionPreset.rawValue,
      framesPerSecond,
      videoBitrate,
      audioBitrate,
      enableAudio,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PlatformPoint {
  var x: Double
  var y: Double

  static func fromList(_ list: [Any]) -> PlatformPoint? {
    let x = list[0] as! Double
    let y = list[1] as! Double

    return PlatformPoint(
      x: x,
      y: y
    )
  }
  func toList() -> [Any?] {
    return [
      x,
      y,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PlatformSize {
  var width: Double
  var height: Double

  static func fromList(_ list: [Any]) -> PlatformSize? {
    let width = list[0] as! Double
    let height = list[1] as! Double

    return PlatformSize(
      width: width,
      height: height
    )
  }
  func toList() -> [Any?] {
    return [
      width,
      height,
    ]
  }
}

private class CameraApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return PlatformCameraDescription.fromList(self.readValue() as! [Any])
      case 129:
        return PlatformMediaSettings.fromList(self.readValue() as! [Any])
      case 130:
        return PlatformPoint.fromList(self.readValue() as! [Any])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class CameraApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? PlatformCameraDescription {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? PlatformMediaSettings {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? PlatformPoint {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class CameraApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return CameraApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return CameraApiCodecWriter(data: data)
  }
}

class CameraApiCodec: FlutterStandardMessageCodec {
  static let shared = CameraApiCodec(readerWriter: CameraApiCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol CameraApi {
  func getAvailableCameras(completion: @escaping (Result<[PlatformCameraDescription?], Error>) -> Void)
  /// Create a new camera with the given settings, and returns its ID.
  func create(cameraName: String, settings: PlatformMediaSettings, completion: @escaping (Result<Int64, Error>) -> Void)
  /// Initializes the camera with the given ID.
  func initialize(cameraId: Int64, imageFormat: PlatformImageFormatGroup, completion: @escaping (Result<Void, Error>) -> Void)
  /// Begins streaming frames from the camera.
  func startImageStream(completion: @escaping (Result<Void, Error>) -> Void)
  /// Stops streaming frames from the camera.
  func stopImageStream(completion: @escaping (Result<Void, Error>) -> Void)
  /// Called by the Dart side of the plugin when it has received the last image
  /// frame sent.
  ///
  /// This is used to throttle sending frames across the channel.
  func receivedImageStreamData(completion: @escaping (Result<Void, Error>) -> Void)
  /// Indicates that the given camera is no longer being used on the Dart side,
  /// and any associated resources can be cleaned up.
  func dispose(cameraId: Int64, completion: @escaping (Result<Void, Error>) -> Void)
  /// Locks the camera capture to the current device orientation.
  func lockCaptureOrientation(orientation: PlatformDeviceOrientation, completion: @escaping (Result<Void, Error>) -> Void)
  /// Unlocks camera capture orientation, allowing it to automatically adapt to
  /// device orientation.
  func unlockCaptureOrientation(completion: @escaping (Result<Void, Error>) -> Void)
  /// Takes a picture with the current settings, and returns the path to the
  /// resulting file.
  func takePicture(completion: @escaping (Result<String, Error>) -> Void)
  /// Does any preprocessing necessary before beginning to record video.
  func prepareForVideoRecording(completion: @escaping (Result<Void, Error>) -> Void)
  /// Begins recording video, optionally enabling streaming to Dart at the same
  /// time.
  func startVideoRecording(enableStream: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  /// Stops recording video, and results the path to the resulting file.
  func stopVideoRecording(completion: @escaping (Result<String, Error>) -> Void)
  /// Pauses video recording.
  func pauseVideoRecording(completion: @escaping (Result<Void, Error>) -> Void)
  /// Resumes a previously paused video recording.
  func resumeVideoRecording(completion: @escaping (Result<Void, Error>) -> Void)
  /// Switches the camera to the given flash mode.
  func setFlashMode(mode: PlatformFlashMode, completion: @escaping (Result<Void, Error>) -> Void)
  /// Switches the camera to the given exposure mode.
  func setExposureMode(mode: PlatformExposureMode, completion: @escaping (Result<Void, Error>) -> Void)
  /// Anchors auto-exposure to the given point in (0,1) coordinate space.
  ///
  /// A null value resets to the default exposure point.
  func setExposurePoint(point: PlatformPoint?, completion: @escaping (Result<Void, Error>) -> Void)
  /// Returns the minimum exposure offset supported by the camera.
  func getMinExposureOffset(completion: @escaping (Result<Double, Error>) -> Void)
  /// Returns the maximum exposure offset supported by the camera.
  func getMaxExposureOffset(completion: @escaping (Result<Double, Error>) -> Void)
  /// Sets the exposure offset manually to the given value.
  func setExposureOffset(offset: Double, completion: @escaping (Result<Void, Error>) -> Void)
  /// Switches the camera to the given focus mode.
  func setFocusMode(mode: PlatformFocusMode, completion: @escaping (Result<Void, Error>) -> Void)
  /// Anchors auto-focus to the given point in (0,1) coordinate space.
  ///
  /// A null value resets to the default focus point.
  func setFocusPoint(point: PlatformPoint?, completion: @escaping (Result<Void, Error>) -> Void)
  /// Returns the minimum zoom level supported by the camera.
  func getMinZoomLevel(completion: @escaping (Result<Double, Error>) -> Void)
  /// Returns the maximum zoom level supported by the camera.
  func getMaxZoomLevel(completion: @escaping (Result<Double, Error>) -> Void)
  /// Sets the zoom factor.
  func setZoomLevel(zoom: Double, completion: @escaping (Result<Void, Error>) -> Void)
  /// Pauses streaming of preview frames.
  func pausePreview(completion: @escaping (Result<Void, Error>) -> Void)
  /// Resumes a previously paused preview stream.
  func resumePreview(completion: @escaping (Result<Void, Error>) -> Void)
  /// Changes the camera used while recording video.
  ///
  /// This should only be called while video recording is active.
  func updateDescriptionWhileRecording(cameraName: String, completion: @escaping (Result<Void, Error>) -> Void)
  /// Sets the file format used for taking pictures.
  func setImageFileFormat(format: PlatformImageFileFormat, completion: @escaping (Result<Void, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class CameraApiSetup {
  /// The codec used by CameraApi.
  static var codec: FlutterStandardMessageCodec { CameraApiCodec.shared }
  /// Sets up an instance of `CameraApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: CameraApi?) {
    let getAvailableCamerasChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.getAvailableCameras", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAvailableCamerasChannel.setMessageHandler { _, reply in
        api.getAvailableCameras() { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      getAvailableCamerasChannel.setMessageHandler(nil)
    }
    /// Create a new camera with the given settings, and returns its ID.
    let createChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.create", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let cameraNameArg = args[0] as! String
        let settingsArg = args[1] as! PlatformMediaSettings
        api.create(cameraName: cameraNameArg, settings: settingsArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      createChannel.setMessageHandler(nil)
    }
    /// Initializes the camera with the given ID.
    let initializeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.initialize", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      initializeChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let cameraIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        let imageFormatArg = PlatformImageFormatGroup(rawValue: args[1] as! Int)!
        api.initialize(cameraId: cameraIdArg, imageFormat: imageFormatArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      initializeChannel.setMessageHandler(nil)
    }
    /// Begins streaming frames from the camera.
    let startImageStreamChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.startImageStream", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      startImageStreamChannel.setMessageHandler { _, reply in
        api.startImageStream() { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      startImageStreamChannel.setMessageHandler(nil)
    }
    /// Stops streaming frames from the camera.
    let stopImageStreamChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.stopImageStream", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stopImageStreamChannel.setMessageHandler { _, reply in
        api.stopImageStream() { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      stopImageStreamChannel.setMessageHandler(nil)
    }
    /// Called by the Dart side of the plugin when it has received the last image
    /// frame sent.
    ///
    /// This is used to throttle sending frames across the channel.
    let receivedImageStreamDataChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.receivedImageStreamData", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      receivedImageStreamDataChannel.setMessageHandler { _, reply in
        api.receivedImageStreamData() { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      receivedImageStreamDataChannel.setMessageHandler(nil)
    }
    /// Indicates that the given camera is no longer being used on the Dart side,
    /// and any associated resources can be cleaned up.
    let disposeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.dispose", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      disposeChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let cameraIdArg = args[0] is Int64 ? args[0] as! Int64 : Int64(args[0] as! Int32)
        api.dispose(cameraId: cameraIdArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      disposeChannel.setMessageHandler(nil)
    }
    /// Locks the camera capture to the current device orientation.
    let lockCaptureOrientationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.lockCaptureOrientation", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      lockCaptureOrientationChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let orientationArg = PlatformDeviceOrientation(rawValue: args[0] as! Int)!
        api.lockCaptureOrientation(orientation: orientationArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      lockCaptureOrientationChannel.setMessageHandler(nil)
    }
    /// Unlocks camera capture orientation, allowing it to automatically adapt to
    /// device orientation.
    let unlockCaptureOrientationChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.unlockCaptureOrientation", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      unlockCaptureOrientationChannel.setMessageHandler { _, reply in
        api.unlockCaptureOrientation() { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      unlockCaptureOrientationChannel.setMessageHandler(nil)
    }
    /// Takes a picture with the current settings, and returns the path to the
    /// resulting file.
    let takePictureChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.takePicture", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      takePictureChannel.setMessageHandler { _, reply in
        api.takePicture() { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      takePictureChannel.setMessageHandler(nil)
    }
    /// Does any preprocessing necessary before beginning to record video.
    let prepareForVideoRecordingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.prepareForVideoRecording", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      prepareForVideoRecordingChannel.setMessageHandler { _, reply in
        api.prepareForVideoRecording() { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      prepareForVideoRecordingChannel.setMessageHandler(nil)
    }
    /// Begins recording video, optionally enabling streaming to Dart at the same
    /// time.
    let startVideoRecordingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.startVideoRecording", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      startVideoRecordingChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let enableStreamArg = args[0] as! Bool
        api.startVideoRecording(enableStream: enableStreamArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      startVideoRecordingChannel.setMessageHandler(nil)
    }
    /// Stops recording video, and results the path to the resulting file.
    let stopVideoRecordingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.stopVideoRecording", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      stopVideoRecordingChannel.setMessageHandler { _, reply in
        api.stopVideoRecording() { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      stopVideoRecordingChannel.setMessageHandler(nil)
    }
    /// Pauses video recording.
    let pauseVideoRecordingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.pauseVideoRecording", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pauseVideoRecordingChannel.setMessageHandler { _, reply in
        api.pauseVideoRecording() { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      pauseVideoRecordingChannel.setMessageHandler(nil)
    }
    /// Resumes a previously paused video recording.
    let resumeVideoRecordingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.resumeVideoRecording", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      resumeVideoRecordingChannel.setMessageHandler { _, reply in
        api.resumeVideoRecording() { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      resumeVideoRecordingChannel.setMessageHandler(nil)
    }
    /// Switches the camera to the given flash mode.
    let setFlashModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.setFlashMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setFlashModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let modeArg = PlatformFlashMode(rawValue: args[0] as! Int)!
        api.setFlashMode(mode: modeArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      setFlashModeChannel.setMessageHandler(nil)
    }
    /// Switches the camera to the given exposure mode.
    let setExposureModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.setExposureMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setExposureModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let modeArg = PlatformExposureMode(rawValue: args[0] as! Int)!
        api.setExposureMode(mode: modeArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      setExposureModeChannel.setMessageHandler(nil)
    }
    /// Anchors auto-exposure to the given point in (0,1) coordinate space.
    ///
    /// A null value resets to the default exposure point.
    let setExposurePointChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.setExposurePoint", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setExposurePointChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let pointArg: PlatformPoint? = nilOrValue(args[0])
        api.setExposurePoint(point: pointArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      setExposurePointChannel.setMessageHandler(nil)
    }
    /// Returns the minimum exposure offset supported by the camera.
    let getMinExposureOffsetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.getMinExposureOffset", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getMinExposureOffsetChannel.setMessageHandler { _, reply in
        api.getMinExposureOffset() { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      getMinExposureOffsetChannel.setMessageHandler(nil)
    }
    /// Returns the maximum exposure offset supported by the camera.
    let getMaxExposureOffsetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.getMaxExposureOffset", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getMaxExposureOffsetChannel.setMessageHandler { _, reply in
        api.getMaxExposureOffset() { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      getMaxExposureOffsetChannel.setMessageHandler(nil)
    }
    /// Sets the exposure offset manually to the given value.
    let setExposureOffsetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.setExposureOffset", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setExposureOffsetChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let offsetArg = args[0] as! Double
        api.setExposureOffset(offset: offsetArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      setExposureOffsetChannel.setMessageHandler(nil)
    }
    /// Switches the camera to the given focus mode.
    let setFocusModeChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.setFocusMode", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setFocusModeChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let modeArg = PlatformFocusMode(rawValue: args[0] as! Int)!
        api.setFocusMode(mode: modeArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      setFocusModeChannel.setMessageHandler(nil)
    }
    /// Anchors auto-focus to the given point in (0,1) coordinate space.
    ///
    /// A null value resets to the default focus point.
    let setFocusPointChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.setFocusPoint", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setFocusPointChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let pointArg: PlatformPoint? = nilOrValue(args[0])
        api.setFocusPoint(point: pointArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      setFocusPointChannel.setMessageHandler(nil)
    }
    /// Returns the minimum zoom level supported by the camera.
    let getMinZoomLevelChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.getMinZoomLevel", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getMinZoomLevelChannel.setMessageHandler { _, reply in
        api.getMinZoomLevel() { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      getMinZoomLevelChannel.setMessageHandler(nil)
    }
    /// Returns the maximum zoom level supported by the camera.
    let getMaxZoomLevelChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.getMaxZoomLevel", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getMaxZoomLevelChannel.setMessageHandler { _, reply in
        api.getMaxZoomLevel() { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      getMaxZoomLevelChannel.setMessageHandler(nil)
    }
    /// Sets the zoom factor.
    let setZoomLevelChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.setZoomLevel", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setZoomLevelChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let zoomArg = args[0] as! Double
        api.setZoomLevel(zoom: zoomArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      setZoomLevelChannel.setMessageHandler(nil)
    }
    /// Pauses streaming of preview frames.
    let pausePreviewChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.pausePreview", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pausePreviewChannel.setMessageHandler { _, reply in
        api.pausePreview() { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      pausePreviewChannel.setMessageHandler(nil)
    }
    /// Resumes a previously paused preview stream.
    let resumePreviewChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.resumePreview", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      resumePreviewChannel.setMessageHandler { _, reply in
        api.resumePreview() { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      resumePreviewChannel.setMessageHandler(nil)
    }
    /// Changes the camera used while recording video.
    ///
    /// This should only be called while video recording is active.
    let updateDescriptionWhileRecordingChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.updateDescriptionWhileRecording", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      updateDescriptionWhileRecordingChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let cameraNameArg = args[0] as! String
        api.updateDescriptionWhileRecording(cameraName: cameraNameArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      updateDescriptionWhileRecordingChannel.setMessageHandler(nil)
    }
    /// Sets the file format used for taking pictures.
    let setImageFileFormatChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraApi.setImageFileFormat", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      setImageFileFormatChannel.setMessageHandler { message, reply in
        let args = message as! [Any]
        let formatArg = PlatformImageFileFormat(rawValue: args[0] as! Int)!
        api.setImageFileFormat(format: formatArg) { result in
          switch result {
            case .success:
              reply(wrapResult(nil))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      setImageFileFormatChannel.setMessageHandler(nil)
    }
  }
}
/// Handler for native callbacks that are not tied to a specific camera ID.
///
/// Generated class from Pigeon that represents Flutter messages that can be called from Swift.
class CameraGlobalEventApi {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  /// Called when the device's physical orientation changes.
  func deviceOrientationChanged(orientation orientationArg: Int64, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraGlobalEventApi.deviceOrientationChanged", binaryMessenger: binaryMessenger)
    channel.sendMessage([orientationArg] as [Any?]) { _ in
      completion()
    }
  }
}
private class CameraEventApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return PlatformCameraState.fromList(self.readValue() as! [Any])
      case 129:
        return PlatformSize.fromList(self.readValue() as! [Any])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class CameraEventApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? PlatformCameraState {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? PlatformSize {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class CameraEventApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return CameraEventApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return CameraEventApiCodecWriter(data: data)
  }
}

class CameraEventApiCodec: FlutterStandardMessageCodec {
  static let shared = CameraEventApiCodec(readerWriter: CameraEventApiCodecReaderWriter())
}

/// Handler for native callbacks that are tied to a specific camera ID.
///
/// This is intended to be initialized with the camera ID as a suffix.
///
/// Generated class from Pigeon that represents Flutter messages that can be called from Swift.
class CameraEventApi {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  var codec: FlutterStandardMessageCodec {
    return CameraEventApiCodec.shared
  }
  /// Called when the camera is inialitized for use.
  func initialized(initialState initialStateArg: PlatformCameraState, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraEventApi.initialized", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([initialStateArg] as [Any?]) { _ in
      completion()
    }
  }
  /// Called when an error occurs in the camera.
  ///
  /// This should be used for errors that occur outside of the context of
  /// handling a specific HostApi call, such as during streaming.
  func error(message messageArg: String, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.CameraEventApi.error", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([messageArg] as [Any?]) { _ in
      completion()
    }
  }
}
